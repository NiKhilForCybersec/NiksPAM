<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="DevOps Secrets Management - Integrating PAM and secrets management with CI/CD pipelines, Kubernetes, and modern development workflows">
    <title>DevOps Secrets Management | PAM & KMS Guide</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="scroll-progress" id="scroll-progress"></div>

    <header class="header">
        <div class="header-content">
            <a href="../index.html" class="logo">
                <div class="logo-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                    </svg>
                </div>
                PAM & KMS Guide
            </a>
            
            <nav class="header-nav">
                <a href="pam-fundamentals.html">PAM</a>
                <a href="kms-fundamentals.html">KMS</a>
                <a href="vendors.html">Vendors</a>
                <a href="implementation.html" class="active">Implementation</a>
            </nav>
            
            <div class="header-actions">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                    </svg>
                </button>
                <button class="mobile-menu-toggle" id="mobile-menu-toggle" aria-label="Toggle menu">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
            </div>
        </div>
    </header>

    <aside class="sidebar" id="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">Advanced Topics</div>
            <ul class="sidebar-nav">
                <li><a href="zero-trust.html">Zero Trust</a></li>
                <li><a href="devops-secrets.html" class="active">DevOps Secrets</a></li>
                <li><a href="ot-ics-security.html">OT/ICS Security</a></li>
            </ul>
        </div>
    </aside>

    <main class="main-wrapper">
        <div class="main-content">
            <nav class="breadcrumb">
                <a href="../index.html">Home</a>
                <span class="breadcrumb-separator">/</span>
                <a href="pam-fundamentals.html">Advanced</a>
                <span class="breadcrumb-separator">/</span>
                <span>DevOps Secrets Management</span>
            </nav>

            <div class="page-header">
                <h1>DevOps Secrets Management</h1>
                <p class="page-description">
                    Modern DevOps practices require secrets management integrated into CI/CD pipelines, container orchestration, and infrastructure as code. This guide covers patterns for securing credentials in automated environments.
                </p>
            </div>

            <div class="toc">
                <div class="toc-title">On This Page</div>
                <ul class="toc-list">
                    <li><a href="#problem"><span class="toc-number">1.</span> The DevOps Secrets Problem</a></li>
                    <li><a href="#patterns"><span class="toc-number">2.</span> Secrets Injection Patterns</a></li>
                    <li><a href="#cicd"><span class="toc-number">3.</span> CI/CD Pipeline Integration</a></li>
                    <li><a href="#kubernetes"><span class="toc-number">4.</span> Kubernetes Secrets</a></li>
                    <li><a href="#hashicorp"><span class="toc-number">5.</span> HashiCorp Vault</a></li>
                    <li><a href="#cloud-secrets"><span class="toc-number">6.</span> Cloud Secrets Managers</a></li>
                    <li><a href="#dynamic"><span class="toc-number">7.</span> Dynamic Secrets</a></li>
                    <li><a href="#best-practices"><span class="toc-number">8.</span> Best Practices</a></li>
                </ul>
            </div>

            <section id="problem">
                <h2>The DevOps Secrets Problem</h2>
                
                <p>
                    Applications need credentials: database passwords, API keys, certificates, encryption keys. Traditional approaches create security risks:
                </p>

                <h3>Anti-Patterns (Don't Do This)</h3>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Anti-Pattern</th>
                                <th>Why It's Bad</th>
                                <th>Real-World Impact</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Hardcoded in source code</strong></td>
                                <td>Everyone with repo access sees secrets</td>
                                <td>Uber 2016: AWS keys in GitHub repo → 57M records exposed</td>
                            </tr>
                            <tr>
                                <td><strong>Environment variables in plain text</strong></td>
                                <td>Visible in process listings, logs, crash dumps</td>
                                <td>Common source of credential exposure</td>
                            </tr>
                            <tr>
                                <td><strong>Config files in deployment</strong></td>
                                <td>Files persist on disk, backups, container images</td>
                                <td>Credentials found in public Docker images</td>
                            </tr>
                            <tr>
                                <td><strong>Shared service accounts</strong></td>
                                <td>No audit trail, can't revoke individual access</td>
                                <td>Lateral movement when any system compromised</td>
                            </tr>
                            <tr>
                                <td><strong>Long-lived credentials</strong></td>
                                <td>If leaked, valid for months/years</td>
                                <td>Extended breach window</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-box warning">
                    <svg class="info-box-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
                    <div class="info-box-content">
                        <h4>The "git commit" Problem</h4>
                        <p>Once a secret is committed to git, it's in the history forever. Even if you delete it in the next commit, anyone can find it. Tools like TruffleHog and git-secrets scan repos for leaked credentials—and attackers use them too.</p>
                    </div>
                </div>

                <h3>What Good Looks Like</h3>

                <ul>
                    <li><strong>Zero secrets in code:</strong> No credentials in source control, ever</li>
                    <li><strong>Runtime retrieval:</strong> Applications fetch secrets at startup from secure store</li>
                    <li><strong>Short-lived credentials:</strong> Secrets expire, forcing rotation</li>
                    <li><strong>Unique identities:</strong> Each application instance has its own identity</li>
                    <li><strong>Audit trail:</strong> Know which application accessed which secret when</li>
                </ul>
            </section>

            <section id="patterns">
                <h2>Secrets Injection Patterns</h2>

                <h3>Pattern 1: Sidecar Injection</h3>

                <p>A sidecar container fetches secrets and makes them available to the application:</p>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
┌─────────────────────────────────────────────────┐
│                      POD                         │
│  ┌──────────────────┐  ┌────────────────────┐   │
│  │   Sidecar        │  │   Application      │   │
│  │   (Vault Agent)  │  │   Container        │   │
│  │                  │  │                    │   │
│  │ 1. Auth to Vault │  │                    │   │
│  │ 2. Fetch secrets │  │ 4. Read from       │   │
│  │ 3. Write to      │──│    shared volume   │   │
│  │    shared volume │  │    or env vars     │   │
│  └──────────────────┘  └────────────────────┘   │
│           │                                      │
│           └──── Shared Volume (/vault/secrets)  │
└─────────────────────────────────────────────────┘
                </pre>

                <ul>
                    <li><strong>Pros:</strong> Application doesn't need secrets SDK, automatic renewal</li>
                    <li><strong>Cons:</strong> Additional container, complexity</li>
                    <li><strong>Use when:</strong> Can't modify application code, need automatic rotation</li>
                </ul>

                <h3>Pattern 2: Init Container</h3>

                <p>Init container fetches secrets before application starts:</p>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
┌─────────────────────────────────────────────────┐
│                      POD                         │
│                                                  │
│  1. Init Container runs first:                  │
│     - Authenticates to secrets manager          │
│     - Fetches secrets                           │
│     - Writes to shared volume                   │
│     - Exits                                     │
│                                                  │
│  2. Application container starts:               │
│     - Reads secrets from volume                 │
│     - Runs normally                             │
│                                                  │
└─────────────────────────────────────────────────┘
                </pre>

                <ul>
                    <li><strong>Pros:</strong> Simpler than sidecar, secrets ready at start</li>
                    <li><strong>Cons:</strong> No automatic refresh (need restart for new secrets)</li>
                    <li><strong>Use when:</strong> Secrets don't change during container lifetime</li>
                </ul>

                <h3>Pattern 3: Direct API Integration</h3>

                <p>Application directly calls secrets manager API:</p>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
// Python example with AWS Secrets Manager
import boto3
import json

def get_secret(secret_name):
    client = boto3.client('secretsmanager')
    response = client.get_secret_value(SecretId=secret_name)
    return json.loads(response['SecretString'])

# At application startup
db_creds = get_secret('prod/database/credentials')
connection = connect_to_db(
    host=db_creds['host'],
    user=db_creds['username'],
    password=db_creds['password']
)
                </pre>

                <ul>
                    <li><strong>Pros:</strong> Most control, can refresh on demand</li>
                    <li><strong>Cons:</strong> Requires code changes, SDK dependency</li>
                    <li><strong>Use when:</strong> Building new applications, need fine-grained control</li>
                </ul>

                <h3>Pattern 4: CSI Volume Mount</h3>

                <p>Kubernetes CSI driver mounts secrets as files:</p>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# Kubernetes manifest
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: app
    volumeMounts:
    - name: secrets
      mountPath: "/mnt/secrets"
      readOnly: true
  volumes:
  - name: secrets
    csi:
      driver: secrets-store.csi.k8s.io
      volumeAttributes:
        secretProviderClass: "vault-database"
                </pre>

                <ul>
                    <li><strong>Pros:</strong> Native Kubernetes, no code changes</li>
                    <li><strong>Cons:</strong> Secrets as files (ensure proper permissions)</li>
                    <li><strong>Use when:</strong> Kubernetes-native, want simplicity</li>
                </ul>
            </section>

            <section id="cicd">
                <h2>CI/CD Pipeline Integration</h2>

                <h3>Jenkins Integration</h3>

                <p>Jenkins can retrieve secrets at runtime using credentials plugins:</p>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
// Jenkinsfile with HashiCorp Vault
pipeline {
    agent any
    
    environment {
        // Secrets retrieved from Vault at runtime
        DB_PASSWORD = vault path: 'secret/prod/database', 
                           key: 'password'
    }
    
    stages {
        stage('Deploy') {
            steps {
                // Password available as environment variable
                // Never logged, never in plain text in pipeline
                sh 'deploy.sh --db-password ${DB_PASSWORD}'
            }
        }
    }
}
                </pre>

                <h3>GitHub Actions</h3>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# .github/workflows/deploy.yml
name: Deploy
on: push

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Get secrets from Vault
        uses: hashicorp/vault-action@v2
        with:
          url: https://vault.example.com
          method: jwt
          role: github-actions
          secrets: |
            secret/data/prod/database password | DB_PASSWORD
            secret/data/prod/api key | API_KEY
      
      - name: Deploy
        run: |
          # Secrets available as environment variables
          ./deploy.sh
        env:
          DB_PASSWORD: ${{ env.DB_PASSWORD }}
                </pre>

                <h3>GitLab CI</h3>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# .gitlab-ci.yml
deploy:
  stage: deploy
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://vault.example.com
  secrets:
    DATABASE_PASSWORD:
      vault: prod/database/password@secret
  script:
    - ./deploy.sh --db-password $DATABASE_PASSWORD
                </pre>

                <h3>Azure DevOps</h3>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# azure-pipelines.yml
steps:
- task: AzureKeyVault@2
  inputs:
    azureSubscription: 'Production'
    KeyVaultName: 'prod-keyvault'
    SecretsFilter: 'DatabasePassword,ApiKey'
    RunAsPreJob: true

- script: |
    ./deploy.sh --db-password $(DatabasePassword)
  displayName: 'Deploy'
                </pre>

                <div class="info-box info">
                    <svg class="info-box-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                    <div class="info-box-content">
                        <h4>Pipeline Identity</h4>
                        <p>Each CI/CD platform has its own way of authenticating to secrets managers: GitHub Actions uses OIDC, Jenkins uses AppRole or certificates, Azure DevOps uses managed identity. Use these native integrations rather than storing static API keys.</p>
                    </div>
                </div>
            </section>

            <section id="kubernetes">
                <h2>Kubernetes Secrets</h2>

                <h3>Native Kubernetes Secrets (Limited Security)</h3>

                <p>Kubernetes has built-in secrets, but they're base64 encoded (not encrypted):</p>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# Native K8s secret - base64 encoded, NOT encrypted!
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
data:
  username: YWRtaW4=      # base64 of "admin"
  password: cGFzc3dvcmQ=  # base64 of "password"
                </pre>

                <div class="info-box warning">
                    <svg class="info-box-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
                    <div class="info-box-content">
                        <h4>K8s Secrets Are Not Secure By Default</h4>
                        <p>Native K8s secrets are: stored unencrypted in etcd (unless you enable encryption at rest), visible to anyone with RBAC access, exposed in YAML manifests. For production, use external secrets managers.</p>
                    </div>
                </div>

                <h3>External Secrets Operator</h3>

                <p>Syncs secrets from external managers into Kubernetes:</p>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# External secret that syncs from AWS Secrets Manager
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: db-credentials
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: ClusterSecretStore
  target:
    name: db-credentials
  data:
    - secretKey: username
      remoteRef:
        key: prod/database
        property: username
    - secretKey: password
      remoteRef:
        key: prod/database
        property: password
                </pre>

                <h3>Vault Secrets Operator</h3>

                <p>HashiCorp's operator for Vault integration:</p>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# VaultStaticSecret for static secrets
apiVersion: secrets.hashicorp.com/v1beta1
kind: VaultStaticSecret
metadata:
  name: db-credentials
spec:
  vaultAuthRef: default
  mount: secret
  path: prod/database
  destination:
    name: db-credentials
    create: true
  refreshAfter: 30s
                </pre>

                <h3>Sealed Secrets</h3>

                <p>Encrypt secrets so they can be stored in git:</p>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# Sealed secret - safe to commit to git
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: db-credentials
spec:
  encryptedData:
    username: AgBghY2... # Encrypted with cluster's public key
    password: AgBxkF3... # Only cluster can decrypt
                </pre>
            </section>

            <section id="hashicorp">
                <h2>HashiCorp Vault</h2>

                <p>
                    HashiCorp Vault is the most popular secrets management platform for DevOps:
                </p>

                <h3>Core Concepts</h3>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Concept</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Secrets Engines</strong></td>
                                <td>Plugins that store/generate secrets (KV, database, PKI, AWS, etc.)</td>
                            </tr>
                            <tr>
                                <td><strong>Auth Methods</strong></td>
                                <td>How clients authenticate (AppRole, Kubernetes, JWT, AWS IAM, etc.)</td>
                            </tr>
                            <tr>
                                <td><strong>Policies</strong></td>
                                <td>What authenticated clients can access (path-based ACLs)</td>
                            </tr>
                            <tr>
                                <td><strong>Tokens</strong></td>
                                <td>After authentication, clients get tokens for API access</td>
                            </tr>
                            <tr>
                                <td><strong>Leases</strong></td>
                                <td>Secrets have TTLs, must be renewed or re-fetched</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Common Auth Methods for DevOps</h3>

                <h4>Kubernetes Auth</h4>
                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# Configure Kubernetes auth method
vault auth enable kubernetes
vault write auth/kubernetes/config \
    kubernetes_host="https://kubernetes.default.svc"

# Create role for specific namespace/service account
vault write auth/kubernetes/role/myapp \
    bound_service_account_names=myapp-sa \
    bound_service_account_namespaces=production \
    policies=myapp-policy \
    ttl=1h
                </pre>

                <h4>AppRole Auth (for CI/CD)</h4>
                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# Enable AppRole
vault auth enable approle

# Create role
vault write auth/approle/role/jenkins \
    token_policies="jenkins-policy" \
    token_ttl=1h \
    secret_id_ttl=24h

# Get role ID (static, stored in Jenkins)
vault read auth/approle/role/jenkins/role-id

# Get secret ID (dynamic, passed securely)
vault write -f auth/approle/role/jenkins/secret-id
                </pre>

                <h3>Example: Application Getting Database Credentials</h3>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# 1. Application authenticates using K8s service account
export VAULT_TOKEN=$(vault write -field=token \
    auth/kubernetes/login \
    role=myapp \
    jwt=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token))

# 2. Application reads secrets
vault kv get -format=json secret/prod/database | jq -r '.data.data'

# Output:
{
  "username": "app_user",
  "password": "s3cr3tP@ssw0rd",
  "host": "db.example.com"
}
                </pre>
            </section>

            <section id="cloud-secrets">
                <h2>Cloud Secrets Managers</h2>

                <h3>AWS Secrets Manager</h3>

                <ul>
                    <li><strong>Integration:</strong> Native AWS service, IAM-based access</li>
                    <li><strong>Rotation:</strong> Built-in Lambda-based rotation for RDS, Redshift, DocumentDB</li>
                    <li><strong>Pricing:</strong> Per secret per month + API calls</li>
                </ul>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# AWS CLI
aws secretsmanager get-secret-value \
    --secret-id prod/database/credentials \
    --query SecretString --output text

# Python boto3
import boto3
client = boto3.client('secretsmanager')
secret = client.get_secret_value(SecretId='prod/database/credentials')
                </pre>

                <h3>Azure Key Vault</h3>

                <ul>
                    <li><strong>Integration:</strong> Azure native, managed identity support</li>
                    <li><strong>Features:</strong> Secrets, keys, and certificates in one service</li>
                    <li><strong>Access:</strong> RBAC or access policies</li>
                </ul>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# Azure CLI
az keyvault secret show \
    --vault-name prod-keyvault \
    --name database-password \
    --query value -o tsv

# Python
from azure.identity import DefaultAzureCredential
from azure.keyvault.secrets import SecretClient

credential = DefaultAzureCredential()
client = SecretClient(
    vault_url="https://prod-keyvault.vault.azure.net/",
    credential=credential
)
secret = client.get_secret("database-password")
                </pre>

                <h3>GCP Secret Manager</h3>

                <ul>
                    <li><strong>Integration:</strong> GCP native, IAM-based access</li>
                    <li><strong>Versioning:</strong> Automatic secret versioning</li>
                    <li><strong>Replication:</strong> Automatic or user-managed</li>
                </ul>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# gcloud CLI
gcloud secrets versions access latest \
    --secret="database-password"

# Python
from google.cloud import secretmanager
client = secretmanager.SecretManagerServiceClient()
name = "projects/my-project/secrets/database-password/versions/latest"
response = client.access_secret_version(request={"name": name})
secret = response.payload.data.decode("UTF-8")
                </pre>
            </section>

            <section id="dynamic">
                <h2>Dynamic Secrets</h2>

                <p>
                    Dynamic secrets are generated on-demand with automatic expiration. They're the gold standard for secrets management.
                </p>

                <h3>How Dynamic Secrets Work</h3>

                <div class="workflow-steps">
                    <div class="workflow-step">
                        <div class="step-number">1</div>
                        <div class="step-content">
                            <h4>Application Requests Secret</h4>
                            <p>Application authenticates to secrets manager and requests database credentials.</p>
                        </div>
                    </div>

                    <div class="workflow-step">
                        <div class="step-number">2</div>
                        <div class="step-content">
                            <h4>Secrets Manager Creates Credential</h4>
                            <p>Secrets manager connects to database, creates a new user with a random password.</p>
                        </div>
                    </div>

                    <div class="workflow-step">
                        <div class="step-number">3</div>
                        <div class="step-content">
                            <h4>Credential Returned with Lease</h4>
                            <p>Application receives username/password with a TTL (e.g., 1 hour).</p>
                        </div>
                    </div>

                    <div class="workflow-step">
                        <div class="step-number">4</div>
                        <div class="step-content">
                            <h4>Automatic Cleanup</h4>
                            <p>When lease expires (or is revoked), secrets manager deletes the database user.</p>
                        </div>
                    </div>
                </div>

                <h3>Vault Database Dynamic Secrets</h3>

                <pre style="background: var(--bg-tertiary); padding: var(--space-4); border-radius: var(--radius-lg); overflow-x: auto; font-family: monospace; font-size: var(--text-sm);">
# Configure database connection
vault write database/config/my-postgresql-database \
    plugin_name=postgresql-database-plugin \
    connection_url="postgresql://{{username}}:{{password}}@db.example.com:5432/mydb" \
    allowed_roles="my-role" \
    username="vault_admin" \
    password="vault_admin_password"

# Create role with creation/revocation statements
vault write database/roles/my-role \
    db_name=my-postgresql-database \
    creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \
        GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"{{name}}\";" \
    default_ttl="1h" \
    max_ttl="24h"

# Application requests credentials
vault read database/creds/my-role
# Returns:
# username: v-approle-my-role-xyz123
# password: A1B2C3D4E5F6...
# lease_duration: 1h
                </pre>

                <div class="info-box success">
                    <svg class="info-box-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
                    <div class="info-box-content">
                        <h4>Why Dynamic Secrets Are Better</h4>
                        <p><strong>No shared credentials:</strong> Each application instance gets unique credentials. <strong>Automatic expiration:</strong> Credentials die automatically. <strong>Easy revocation:</strong> Revoke one application without affecting others. <strong>Audit trail:</strong> Know exactly which credential was used when.</p>
                    </div>
                </div>
            </section>

            <section id="best-practices">
                <h2>Best Practices</h2>

                <h3>1. Zero Secrets in Code</h3>
                <ul>
                    <li>Use pre-commit hooks to scan for secrets (git-secrets, detect-secrets)</li>
                    <li>Scan repos regularly with tools like TruffleHog</li>
                    <li>Train developers—secrets in code is a firing offense at many companies</li>
                </ul>

                <h3>2. Short-Lived Credentials</h3>
                <ul>
                    <li>Dynamic secrets where possible (hours, not days)</li>
                    <li>For static secrets, rotate at least every 90 days</li>
                    <li>Rotate immediately if any suspicion of compromise</li>
                </ul>

                <h3>3. Unique Application Identities</h3>
                <ul>
                    <li>Each service has its own identity (service account, IAM role)</li>
                    <li>Each instance/pod authenticates independently</li>
                    <li>No shared "deployment" accounts across services</li>
                </ul>

                <h3>4. Least Privilege</h3>
                <ul>
                    <li>Applications only access secrets they need</li>
                    <li>Database credentials with minimum required permissions</li>
                    <li>Separate secrets per environment (dev/staging/prod)</li>
                </ul>

                <h3>5. Audit Everything</h3>
                <ul>
                    <li>Log all secret access</li>
                    <li>Alert on unusual patterns (new applications, unusual times)</li>
                    <li>Regular access reviews</li>
                </ul>

                <h3>6. Secure the Secrets Manager</h3>
                <ul>
                    <li>The secrets manager is now your most critical system</li>
                    <li>HSM for master key protection</li>
                    <li>HA/DR for availability</li>
                    <li>Restrict admin access heavily</li>
                </ul>
            </section>

            <div class="info-box success">
                <svg class="info-box-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
                <div class="info-box-content">
                    <h4>Key Takeaways</h4>
                    <p>DevOps secrets management eliminates hardcoded credentials in favor of runtime retrieval from secure stores. Use injection patterns appropriate for your environment (sidecar, init, API, CSI). Prefer dynamic secrets that expire automatically. Integrate secrets managers into CI/CD pipelines using native authentication methods. HashiCorp Vault and cloud-native secrets managers are the leading solutions.</p>
                </div>
            </div>

            <nav class="page-nav">
                <a href="zero-trust.html" class="page-nav-link prev">
                    <span class="page-nav-label">Previous</span>
                    <span class="page-nav-title">← Zero Trust</span>
                </a>
                <a href="ot-ics-security.html" class="page-nav-link next">
                    <span class="page-nav-label">Next</span>
                    <span class="page-nav-title">OT/ICS Security →</span>
                </a>
            </nav>
        </div>

        <footer class="footer">
            <p>PAM & KMS Ultimate Guide — A comprehensive enterprise security documentation resource</p>
        </footer>
    </main>

    <button class="back-to-top" id="back-to-top" aria-label="Back to top">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="18 15 12 9 6 15"></polyline>
        </svg>
    </button>

    <script src="../js/main.js"></script>
</body>
</html>
